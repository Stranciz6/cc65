#!/usr/bin/perl
###############################################################################
#                                                                             #
# 				    main.c				      #
#                                                                             #
# 		       Convert a ca65 source into HTML			      #
#                                                                             #
#                                                                             #
#                                                                             #
#  (C) 2000-2007 Ullrich von Bassewitz                                        #
#                R÷merstrasse 52                                              #
#                D-70794 Filderstadt                                          #
#  EMail:        uz@cc65.org                                                  #
#                                                                             #
#                                                                             #
#  This software is provided 'as-is', without any expressed or implied        #
#  warranty.  In no event will the authors be held liable for any damages     #
#  arising from the use of this software.                                     #
#                                                                             #
#  Permission is granted to anyone to use this software for any purpose,      #
#  including commercial applications, and to alter it and redistribute it     #
#  freely, subject to the following restrictions:                             #
#                                                                             #
#  1. The origin of this software must not be misrepresented; you must not    #
#     claim that you wrote the original software. If you use this software    #
#     in a product, an acknowledgment in the product documentation would be   #
#     appreciated but is not required.                                        #
#  2. Altered source versions must be plainly marked as such, and must not    #
#     be misrepresented as being the original software.                       #
#  3. This notice may not be removed or altered from any source               #
#     distribution.                                                           #
#                                                                             #
###############################################################################



# Things currently missing:
#
#   - Scoping with .proc/.endproc
#   - .global is ignored
#   - .constructor/.destructor/.condes dito
#   - .ignorecase is ignored, labels are always case sensitive
#   - .include handling (difficult)
#   - The global namespace operator ::
#



use strict 'vars';
use warnings;

# Modules
use Getopt::Long;



#-----------------------------------------------------------------------------#
#    		  	  	   Variables				      #
# ----------------------------------------------------------------------------#



# Global variables
my %Files      	    = ();      	    # List of all files.
my $FileCount  	    = 0;       	    # Number of input files
my %Exports    	    = ();      	    # List of exported symbols.
my %Imports    	    = ();      	    # List of imported symbols.
my %Labels     	    = ();      	    # List of all labels
my $LabelNum   	    = 0;       	    # Counter to generate unique labels

# Command line options
my $BGColor    	    = "#FFFFFF";    # Background color
my $Colorize        = 0;            # Colorize the output
my $CommentColor    = "#B22222";    # Color for comments
my $CRefs           = 0;            # Add references to the C file
my $CtrlColor       = "#228B22";    # Color for control directives
my $CvtTabs	    = 0;	    # Convert tabs to spaces
my $Debug      	    = 0;       	    # No debugging
my $Help       	    = 0;       	    # Help flag
my $HTMLDir    	    = "";      	    # Directory in which to create the files
my $IndexCols  	    = 6;       	    # Columns in the file listing
my $IndexTitle 	    = "Index"; 	    # Title of index page
my $IndexName  	    = "index.html"; # Name of index page
my $IndexPage  	    = 0;       	    # Create an index page
my $KeywordColor    = "#A020F0";    # Color for keywords
my $LineLabels      = 0;            # Add a HTML label to each line
my $LineNumbers     = 0;            # Add line numbers to the output
my $LinkStyle  	    = 0;       	    # Default link style
my $ReplaceExt 	    = 0;       	    # Replace extension instead of appending
my $StringColor     = "#6169C1";    # Color for strings
my $TextColor  	    = "#000000";    # Text color
my $Verbose    	    = 0;       	    # Be quiet

# Table used to convert the label number into names
my @NameTab    	    = ("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K",
               	       "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V",
       	       	       "W", "X", "Y", "Z", "0", "1", "2", "3", "4", "5", "6",
       	       	       "7", "8", "9");



#-----------------------------------------------------------------------------#
#     			       Helper functions				      #
# ----------------------------------------------------------------------------#



# Terminate with an error
sub Abort {
    print STDERR "ca65html: @_\n";
    exit 1;
}

# Print a message if verbose is true
sub Gabble {
    if ($Verbose) {
      	print "ca65html: @_\n";
    }
}

# Generate a label and return it
sub GenLabel {

    my $I;
    my $L = "";;
    my $Num = $LabelNum++;

    # Generate the label
    for ($I = 0; $I < 4; $I++) {
	$L = $NameTab[$Num % 36] . $L;
	$Num /= 36;
    }
    return $L;
}

# Make an output file name from an input file name
sub GetOutName {

    # Input name is parameter
    my $InName = $_[0];

    # Create the output file name from the input file name
    if ($ReplaceExt && $InName =~ /^(.+)\.([^\.\/]*)$/) {
       	return "$1.html";
    } else {
       	return "$InName.html";
    }
}

# Remove illegal characters from a string
sub Cleanup {
    my $S = shift (@_);
    $S =~ s/&/&amp;/g;
    $S =~ s/</&lt;/g;
    $S =~ s/>/&gt;/g;
    $S =~ s/\"/&quot;/g;
    return $S;
}

# Strip a path from a filename and return just the name
sub StripPath {

    # Filename is argument
    my $FileName = $_[0];

    # Remove a path name if we have one
    $FileName =~ /^(.*?)([^\/]*)$/;
    return $2;
}



#-----------------------------------------------------------------------------#
#		  	  Document header and footer			      #
# ----------------------------------------------------------------------------#



# Print the document header
sub DocHeader {
    my $OUT = shift (@_);
    my $Asm = shift (@_);
    if (not $Colorize) {
        # Colorization generates invalid HTML. Common browsers display it
        # correctly, but we don't claim it adheres to some standard ...
        print $OUT "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n";
    }
    print $OUT <<"EOF";
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="ca65html">
<title>$Asm</title>
</head>
<body bgcolor="$BGColor" text="$TextColor" link="#0000d0" vlink="#000060" alink="#00d0d0">
<p><br><p>
<center><h1>$Asm</h1></center>
<hr size="1" noshade><p><br><p>
EOF
}

# Print the document footer
sub DocFooter {
    my $OUT  = shift (@_);
    my $Name = shift (@_);

    # Get the current date and time
    my $Today = localtime;

    # Print
    print $OUT "<p><br><p>\n";
    print $OUT "<hr size=\"1\" noshade>\n";
    print $OUT "<address>\n";
    if (not $Colorize) {
        print $OUT "<a href=\"http://validator.w3.org/check/referer\"><img border=\"0\" src=\"http://www.w3.org/Icons/valid-html401\" alt=\"Valid HTML 4.01!\" height=\"31\" width=\"88\" align=\"right\"></a>\n";
    }
    print $OUT "$Name; generated on $Today by ca65html<br>\n";
    print $OUT "<a href=\"mailto:uz&#64;cc65.org\">uz&#64;cc65.org</a>\n";
    print $OUT "</address>\n";
    print $OUT "</body>\n";
    print $OUT "</html>\n";
}



#-----------------------------------------------------------------------------#
#                                Colorization                                 #
#-----------------------------------------------------------------------------#



sub ColorizeComment {
    if ($Colorize && $_[0] ne "") {
        return "<font color=\"$CommentColor\">$_[0]</font>";
    } else {
        return $_[0];
    }
}



sub ColorizeCtrl {
    if ($Colorize) {
        return "<font color=\"$CtrlColor\">$_[0]</font>";
    } else {
        return $_[0];
    }
}



sub ColorizeKeyword {
    if ($Colorize) {
        return "<font color=\"$KeywordColor\">$_[0]</font>";
    } else {
        return $_[0];
    }
}



sub ColorizeString {
    if ($Colorize) {
        return "<font color=\"$StringColor\">$_[0]</font>";
    } else {
        return $_[0];
    }
}



#-----------------------------------------------------------------------------#
# 			     File list management			      #
#-----------------------------------------------------------------------------#



sub AddFile {

    # Argument is file to add
    my $FileName = $_[0];

    # Get just the name (remove a path if there is one)
    my $Name = StripPath ($FileName);

    # Check if we have the file already
    if (exists ($Files{$Name})) {
    	Gabble ("File \"$FileName\" already known");
    	return;
    }

    # Check with the full pathname. If we don't find it, search in the current
    # directory
    if (-f $FileName && -r _) {
    	$Files{$Name} = $FileName;
    	$FileCount++;
    } elsif (-f $Name && -r _) {
    	$Files{$Name} = $Name;
    	$FileCount++;
    } else {
     	Abort ("$FileName not found or not readable");
    }
}



#-----------------------------------------------------------------------------#
#   			Referencing and defining labels			      #
#-----------------------------------------------------------------------------#



# Get a label reference
sub RefLabel {

    # Arguments are: Filename, identifier, item that should be tagged
    my $FileName = $_[0];
    my $Id       = $_[1];
    my $Item  	 = $_[2];

    # Search for the identifier in the list of labels
    if (exists ($Labels{$FileName}{$Id})) {
	# It is a label (in this file)
	return sprintf ("<a href=\"#%s\">%s</a>", $Labels{$FileName}{$Id}, $Item);
    } elsif (exists ($Imports{$FileName}{$Id})) {
       	# It is an import. If LinkStyle is 1, or if the file exporting the
	# identifier is not visible, we link to the .import statement in the
	# current file. Otherwise we link directly to the referenced symbol
	# in the file that exports it.
	if ($LinkStyle == 1 or not exists ($Exports{$Id})) {
	    return sprintf ("<a href=\"#%s\">%s</a>", $Imports{$FileName}{$Id}, $Item);
	} else {
	    # Get the filename from the export
	    my $Label;
       	    ($FileName, $Label) = split (/#/, $Exports{$Id});
       	    if (not defined ($Labels{$FileName}{$Id})) {
		# This may currently happen because we don't see .include
		# statements, so we may have an export but no definition.
		# Link to the .export statement instead
		$Label = $Exports{$Id};
	    } else {
		# Link to the definition in the file
		$Label = sprintf ("%s#%s", $FileName, $Labels{$FileName}{$Id});
	    }
	    return sprintf ("<a href=\"%s\">%s</a>", $Label, $Item);
	}
    } else {
	# The symbol is unknown, return as is
	return $Item;
    }
}



#-----------------------------------------------------------------------------#
#    	     	   	       	    Pass 1 		   		      #
# ----------------------------------------------------------------------------#



# Process1: Read one file for the first time.
sub Process1 {

    # Variables
    my $Line;
    my $Id;

    # Filename is parameter
    my $InName = shift(@_);

    # Create the output file name from the input file name
    my $OutName = GetOutName ($InName);

    # Current cheap local label prefix is empty
    my $CheapPrefix = "";

    # Open a the input file
    my $FileName = $Files{$InName};	# Includes path if needed
    open (INPUT, "<$FileName") or Abort ("Cannot open $FileName: $!");

    # Keep the user happy
    Gabble ("$FileName => $OutName");

    # Read and process all lines from the file
    while ($Line = <INPUT>) {

       	# Remove the newline
       	chop ($Line);

       	# Check for a label
        if ($Line =~ /^\s*(\@?)([_a-zA-Z]\w*)(:(?!=)|\s*:?=)/) {

	    # Is this a local label?
	    if ($1 eq "\@") {
	       	# Use the prefix
	       	$Id = "$CheapPrefix$1$2";
	    } else {
	       	# Use as is
	       	$Id = $2;
	       	# Remember the id as new cheap local prefix
	       	$CheapPrefix = $Id;
	    }

	    # Remember the label
	    $Labels{$OutName}{$Id} = GenLabel();

      	# Check for an import statement
	} elsif ($Line =~ /^\s*(\.import|\.importzp)\s+(.*?)(\s*)(;.*$|$)/) {

	    # Split into a list of identifiers
	    my @Ids = split (/\s*,\s*/, $2);
	    for $Id (@Ids) {
	       	$Imports{$OutName}{$Id} = GenLabel();
	    }

	# Check for an export statement
	} elsif ($Line =~ /^\s*(\.export|\.exportzp)\s+(.*?)(\s*)(;.*$|$)/) {

	    # Split into a list of identifiers
	    my @Ids = split (/\s*,\s*/, $2);
       	    for $Id (@Ids) {
	       	$Exports{$Id} = sprintf ("%s#%s", $OutName, GenLabel());
	    }

	# Check for a .proc statement
       	} elsif ($Line =~ /^\s*\.proc\s+([_a-zA-Z]\w*)?.*$/) {

	    # Do we have an id?
	    $Id = $1;
	    if ($Id ne "") {
	       	$Labels{$OutName}{$Id} = GenLabel();
	    }

     	}
    }

    # Close the input file
    close (INPUT);
}



# Pass1: Read all files for the first time.
sub Pass1 () {

    # Keep the user happy
    Gabble ("Pass 1");

    # Walk over the files
    for my $InName (keys (%Files)) {
     	# Process one file
      	Process1 ($InName);
    }
}



#-----------------------------------------------------------------------------#
#    		     		    Pass 2				      #
# ----------------------------------------------------------------------------#



# Process2: Read one file the second time.
sub Process2 {

    # Variables
    my $Base;
    my $Ext;
    my $Line;
    my $OutLine;
    my $Id;
    my $Label;
    my $Operand;
    my $Comment;
    my $Trailer;

    # Input file is parameter
    my $InName = shift(@_);

    # Create the output file name from the input file name
    my $OutName = GetOutName ($InName);

    # Current cheap local label prefix is empty
    my $CheapPrefix = "";

    # Open a the input file
    my $FileName = $Files{$InName};	# Includes path if needed
    open (INPUT, "<$FileName") or Abort ("Cannot open $FileName: $!");

    # Open the output file and print the HTML header
    open (OUTPUT, ">$HTMLDir$OutName") or Abort ("Cannot open $OutName: $!");
    DocHeader (OUTPUT, $InName);
    print OUTPUT "<pre>\n";

    # Keep the user happy
    Gabble ("$FileName => $OutName");

    # The instructions that will have hyperlinks if a label is used
    my $LabelIns = "adc|add|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|bra|bvc|bvs|".
	           "cmp|cpx|cpy|dec|eor|inc|jmp|jsr|lda|ldx|ldy|lsr|ora|rol|".
	           "ror|sbc|sta|stx|sty|stz|sub|";

    # The instructions that will have hyperlinks if a label is used
    my $AllIns = "adc|add|and|asl|bcc|bcs|beq|bge|bit|blt|bmi|bne|bpl|bvc|".
		 "bra|brk|brl|bvs|clc|cld|cli|clv|cmp|cop|cpa|cpx|cpy|dea|".
		 "dec|dex|dey|eor|ina|inc|inx|iny|jml|jmp|jsl|jsr|lda|ldx|".
		 "ldy|lsr|mvn|mvp|nop|ora|pea|pei|per|pha|phb|phd|phk|php|".
		 "phx|phy|pla|plb|pld|plp|plx|ply|rep|rol|ror|rti|rtl|rts|".
		 "sbc|sec|sed|sei|sep|sta|stx|sty|stz|sub|swa|tad|tax|tay|".
		 "tcd|tcs|tda|tdc|trb|tsa|tsb|tsc|tsx|txa|txs|txy|tya|tyx|".
		 "wai|xba|xce";

    # Read the input file, replacing references by hyperlinks and mark
    # labels as link targets.
    my $LineNo = 0;
    while ($Line = <INPUT>) {

        # Count input lines
        $LineNo++;

 	# Remove the newline
	chop ($Line);

        # If requested, convert tabs to spaces
	if ($CvtTabs) {
	    # Don't ask me - this is from the perl manual page
	    1 while ($Line =~ s/\t+/' ' x (length($&)*8 - length($`)%8)/e) ;
	}

       	# Clear the output line
	$OutLine = "";

        # If requested, add a html label to each line with a name "linexxx",
        # so it can be referenced from the outside (this is the same convention
        # that is used by c2html). If we have line numbers enabled, add them.
        if ($LineLabels && $LineNumbers) {
            $OutLine .= sprintf ("<a name=\"line%d\">%6d</a>:  ", $LineNo, $LineNo);
        } elsif ($LineLabels) {
            $OutLine .= sprintf ("<a name=\"line%d\"></a>", $LineNo);
        } elsif ($LineNumbers) {
            $OutLine .= sprintf ("%6d:  ", $LineNo);
        }

        # Cut off a comment from the input line. Beware: We have to check for
        # strings, since these may contain a semicolon that is no comment
        # start.
        ($Line, $Comment) = $Line =~ /^((?:[^"';]+|".*?"|'.*?')*)(.*)$/;
        if ($Comment =~ /^["']/) {
            # Line with invalid syntax - there's a string start but
            # no string end.
            Abort (sprintf ("Invalid input at %s(%d)", $FileName, $LineNo));
        }

        # Remove trailing whitespace and move it together with the comment
        # into the $Trailer variable.
       	$Line =~ s/\s*$//;
	$Trailer = $& . ColorizeComment (Cleanup ($Comment));

       	# Check for a label at the start of the line. If we have one, process
        # it and remove it from the line
        if ($Line =~ s/^\s*?(\@?)([_a-zA-Z]\w*)(:(?!=)|\s*:?=)//) {

	    # Is this a local label?
       	    if ($1 eq "\@") {
		# Use the prefix
	     	$Id = "$CheapPrefix$1$2";
	    } else {
	      	# Use as is
	      	$Id = $2;
	      	# Remember the id as new cheap local prefix
	      	$CheapPrefix = $Id;
	    }

	    # Get the label for the id
	    $Label = $Labels{$OutName}{$Id};

	    # Print the label with a tag
       	    $OutLine .= sprintf ("<a name=\"%s\">%s%s</a>%s", $Label, $1, $2, $3);
	}

	# Print any leading whitespace and remove it, so we don't have to
	# care about whitespace below.
	if ($Line =~ s/^\s+//) {
      	    $OutLine .= $&;
	}

	# Handle the import statements
	if ($Line =~ s/^(\.import|\.importzp)\s+//) {

	    # Print any fixed stuff from the line and remove it
       	    $OutLine .= $&;

 	    # Print all identifiers if there are any
 	    while ($Line =~ s/^[_a-zA-Z]\w*//) {

                # Remember the identifier
       	       	my $Id = $&;

		# Variable to assemble HTML representation
       	       	my $Contents = "";

		# Make this import a link target
		if (exists ($Imports{$OutName}{$Id})) {
       	       	    $Label = $Imports{$OutName}{$Id};
       	       	    $Contents .= sprintf (" name=\"%s\"", $Label);
		}

		# If we have an export for this import, add a link to this
	     	# export definition
		if (exists ($Exports{$Id})) {
		    $Label = $Exports{$Id};
		    $Contents .= sprintf (" href=\"%s\"", $Label);
		}

     		# Add the HTML stuff to the output line
		if ($Contents ne "") {
		    $OutLine .= sprintf ("<a%s>%s</a>", $Contents, $Id);
		} else {
		    $OutLine .= $Id;
		}

	     	# Check if another identifier follows
		if ($Line =~ s/^\s*,\s*//) {
     		    $OutLine .= $&;
       	     	} else {
		    last;
      		}
	    }

	    # Add an remainder if there is one
	    $OutLine .= Cleanup ($Line);

       	# Handle export statements
	} elsif ($Line =~ s/^(\.export|\.exportzp)\s+//) {

	    # Print the command the and white space
	    $OutLine .= $&;

	    # Print all identifiers if there are any
	    while ($Line =~ s/^[_a-zA-Z]\w*//) {

                # Remember the identifier
       	       	my $Id = $&;

		# Variable to assemble HTML representation
       	       	my $Contents = "";

		# If we have a definition for this export in this file, add
		# a link to the definition.
		if (exists ($Labels{$OutName}{$Id})) {
		    $Label = $Labels{$OutName}{$Id};
       	       	    $Contents = sprintf (" href=\"#%s\"", $Label);
		}

		# If we have this identifier in the list of exports, add a
		# jump target for the export.
		if (exists ($Exports{$Id})) {
		    $Label = $Exports{$Id};
       	       	    # Be sure to use only the label part
		    $Label =~ s/^.*#//;
		    $Contents .= sprintf (" name=\"%s\"", $Label);
	     	}

     		# Add the HTML stuff to the output line
		if ($Contents ne "") {
	     	    $OutLine .= sprintf ("<a%s>%s</a>", $Contents, $Id);
		} else {
		    $OutLine .= $Id;
		}

     		# Check if another identifier follows
      	      	if ($Line =~ s/^\s*,\s*//) {
     	    	    $OutLine .= $&;
     		} else {
     		    last;
     		}
     	    }

     	    # Add an remainder if there is one
     	    $OutLine .= Cleanup ($Line);

     	# Check for .addr and .word
     	} elsif ($Line =~ s/^(\.addr|\.word)\s+//) {

     	    # Print the command and the white space
       	    $OutLine .= $&;

     	    # Print all identifiers if there are any
       	    while ($Line =~ /^([^_a-zA-Z]*)([_a-zA-Z]\w*)(.*)$/) {
                # Add the non label stuff
                $OutLine .= Cleanup ($1);

                # If the identifier is a known label, add a link
     		if (exists ($Labels{$OutName}{$2})) {
     		    $Label = $Labels{$OutName}{$2};
       	       	    $OutLine .= sprintf ("<a href=\"#%s\">%s</a>", $Label, $2);
     		} else {
     		    $OutLine .= $2;
     		}

                # Proceed with the remainder of the line
     		$Line = $3;
     	    }

     	    # Add an remainder if there is one
     	    $OutLine .= Cleanup ($Line);

	# Handle .proc
       	} elsif ($Line =~ /^(\.proc)(\s+)([_a-zA-Z]\w*)?(.*)$/) {

	    # Do we have an identifier?
	    if ($3 ne "") {
      	      	# Get the label for the id
	    	$Label = $Labels{$OutName}{$3};

		# Print the label with a tag
		$OutLine .= "$1$2<a name=\"$Label\">$3</a>";

	    } else {

		# Print the label
       	       	$OutLine .= "$1$2$3";

            }

            # Add the remainder
            $OutLine .= Cleanup ($4);

	# Handle .include
	} elsif ($Line =~ /^(\.include)(\s+)\"((?:[^\"]+?|\\\")+)(\".*)$/) {

	    # Add the fixed stuff to the output line
	    $OutLine .= "$1$2&quot;";

	    # Get the filename into a named variable
	    my $FileName = Cleanup ($3);

	    # Get the name without a path
	    my $Name = StripPath ($3);

	    # If the include file is among the list of our files, add a link,
	    # otherwise just add the name as is.
	    if (exists ($Files{$Name})) {
	    	$OutLine .= sprintf ("<a href=\"%s\">%s</a>", GetOutName ($Name), $FileName);
	    } else {
	    	$OutLine .= $FileName;
	    }

	    # Add the remainder
	    $OutLine .= Cleanup ($4);

        # Handle .dbg line
        } elsif ($CRefs && $Line =~ s/^\.dbg\s+//) {

            # Add the fixed stuff to the output line
            $OutLine .= $&;

            # Check for the type of the .dbg directive
            if ($Line =~ /^(line,\s*)\"((?:[^\"]+?|\\\")+)\"(,\s*)(\d+)(.*)$/) {

                # Add the fixed stuff to the output line
                $OutLine .= "$1&quot;";

                # Get the filename and line number into named variables
                my $DbgFile = $2;
                my $DbgLine = $4;

                # Remember the remainder
                $Line = "\"$3$4$5";

                # Get the name without a path
                my $Name = StripPath ($DbgFile);

                # We don't need FileName any longer as is, so clean it up
                $DbgFile = Cleanup ($DbgFile);

                # Add a link to the source file
                $OutLine .= sprintf ("<a href=\"%s.html#line%d\">%s</a>", $Name, $DbgLine, $DbgFile);

                # Add the remainder
                $OutLine .= Cleanup ($Line);

            } elsif ($Line =~ /^(file,\s*)\"((?:[^\"]+?|\\\")+)\"(.*)$/) { #pf FIXME: doesn't handle \" correctly!

                # Get the filename into a named variables
                my $DbgFile = Cleanup ($2);

                # Get the name without a path
                my $Name = Cleanup (StripPath ($2));

                # Add the fixed stuff to the output line
                $OutLine .= sprintf ("%s\"<a href=\"%s.html\">%s</a>\"%s",
                                     $1, $Name, $DbgFile, $3);

            } else {

                # Add the remainder
                $OutLine .= Cleanup ($Line);

            }

        } elsif ($CRefs && $Line =~ /^(\.dbg)(\s+line,\s*)\"((?:[^\"]+?|\\\")+)\"(,\s*)(\d+)(.*$)/) {

            # Add the fixed stuff to the output line
            $OutLine .= "$1$2&quot;";

	    # Get the filename and line number into named variables
	    my $FileName = $3;
            my $LineNo   = $5;

	    # Remember the remainder
	    $Line = "\"$4$5$6";

	    # Get the name without a path
	    my $Name = StripPath ($FileName);

	    # We don't need FileName any longer as is, so clean it up
	    $FileName = Cleanup ($FileName);

       	    # Add a link to the source file
       	    $OutLine .= sprintf ("<a href=\"%s.html#line%d\">%s</a>", $Name, $LineNo, $FileName);

	    # Add the remainder
	    $OutLine .= Cleanup ($Line);

     	# Check for instructions with labels
        } elsif ($Line =~ /^($LabelIns)\b(\s+)(.*)$/) {

	    # Print the instruction and white space
            $OutLine .= ColorizeKeyword ($1) . $2;

	    # Remember the remaining parts
	    $Operand = $3;

  	    # Check for the first identifier in the operand and replace it
    	    # by a hyperlink
       	    if ($Operand =~ /^([^_a-zA-Z]*?)(\@?)([_a-zA-Z]\w*)(.*)$/) {

		# Is this a local label?
		if ($2 eq "\@") {
		    # Use the prefix
		    $Id = "$CheapPrefix$2$3";
	     	} else {
	     	    # Use as is
	     	    $Id = $3;
	     	}

	     	# Get the reference to this label if we find it
	     	$Operand = Cleanup($1) . RefLabel($OutName, $Id, $2 . $3) . Cleanup($4);
	    }

	    # Reassemble and print the line
       	    $OutLine .= $Operand;

     	# Check for all other instructions
        } elsif ($Line =~ /^($AllIns)\b(.*)$/) {

	    # Colorize and print
            $OutLine .= ColorizeKeyword ($1) . Cleanup ($2);

      	} else {

	    # Nothing known - print the line
	    $OutLine .= Cleanup ($Line);

	}

        # Colorize all keywords
       	$OutLine =~ s/(?<![\w;])\.[_a-zA-Z]\w*/ColorizeCtrl ($&)/ge;

        # Add the trailer
        $OutLine .= $Trailer;

	# Print the result
     	print OUTPUT "$OutLine\n";
    }

    # Print the HTML footer
    print OUTPUT "</pre>\n";
    DocFooter (OUTPUT, $OutName);

    # Close the files
    close (INPUT);
    close (OUTPUT);
}



# Pass2: Read all files the second time.
sub Pass2 () {

    # Keep the user happy
    Gabble ("Pass 2");

    # Walk over the files
    for my $InName (keys (%Files)) {
       	# Process one file
       	Process2 ($InName);
    }
}



#-----------------------------------------------------------------------------#
#		   	     Create an index page     			      #
# ----------------------------------------------------------------------------#



# Print a list of all files
sub FileIndex {

    # File is argument
    my $INDEX = $_[0];

    # Print the file list in a table
    print $INDEX "<h2>Files</h2><p>\n";
    print $INDEX "<table border=\"0\" width=\"100%\">\n";
    my $Count = 0;
    for my $File (sort (keys (%Files))) {

	#
     	if (($Count % $IndexCols) == 0) {
     	    print $INDEX "<tr>\n";
     	}
     	printf $INDEX "<td><a href=\"%s\">%s</a></td>\n", GetOutName ($File), $File;
     	if (($Count % $IndexCols) == $IndexCols-1) {
     	    print $INDEX "</tr>\n";
     	}
     	$Count++;
    }
    if (($Count % $IndexCols) != 0) {
     	print $INDEX "</tr>\n";
    }
    print $INDEX "</table><p><br><p>\n";
}



# Print a list of all exports
sub ExportIndex {

    # File is argument
    my $INDEX = $_[0];

    # Print the file list in a table
    print $INDEX "<h2>Exports</h2><p>\n";
    print $INDEX "<table border=\"0\" width=\"100%\">\n";
    my $Count = 0;
    for my $Export (sort (keys (%Exports))) {

	# Get the export
	my $File;
	my $Label;
	($File, $Label) = split (/#/, $Exports{$Export});

	# The label is the label of the export statement. If we can find the
	# actual label, use this instead.
       	if (exists ($Labels{$File}{$Export})) {
	    $Label = $Labels{$File}{$Export};
	}

	#
	if (($Count % $IndexCols) == 0) {
	    print $INDEX "<tr>\n";
	}
	printf $INDEX "<td><a href=\"%s#%s\">%s</a></td>\n", $File, $Label, $Export;
	if (($Count % $IndexCols) == $IndexCols-1) {
	    print $INDEX "</tr>\n";
	}
	$Count++;
    }
    if (($Count % $IndexCols) != 0) {
	print $INDEX "</tr>\n";
    }
    print $INDEX "</table><p><br><p>\n";
}



sub CreateIndex {

    # Open the index page file
    open (INDEX, ">$HTMLDir$IndexName") or Abort ("Cannot open $IndexName: $!");

    # Print the header
    DocHeader (INDEX, $IndexTitle, 0);

    # Print the file list in a table
    FileIndex (INDEX);
    ExportIndex (INDEX);

    # Print the document footer
    DocFooter (INDEX, $IndexName);

    # Close the index file
    close (INDEX);
}



#-----------------------------------------------------------------------------#
#			    Print usage information			      #
# ----------------------------------------------------------------------------#



sub Usage {
    print "Usage: ca65html [options] file ...\n";
    print "Options:\n";
    print "  --bgcolor c        Use background color c instead of $BGColor\n";
    print "  --colorize         Colorize the output (generates non standard HTML)\n";
    print "  --commentcolor c   Use color c for comments instead of $CommentColor\n";
    print "  --crefs            Generate references to the C source file(s)\n";
    print "  --ctrlcolor c      Use color c for directives instead of $CtrlColor\n";
    print "  --cvttabs          Convert tabs to spaces in the output\n";
    print "  --help             This text\n";
    print "  --htmldir dir      Specify directory for HTML files\n";
    print "  --indexcols n      Use n columns on index page (default $IndexCols)\n";
    print "  --indexname file   Use file for the index file instead of $IndexName\n";
    print "  --indexpage        Create an index page\n";
    print "  --indextitle title Use title as the index title instead of $IndexTitle\n";
    print "  --keywordcolor c   Use color c for keywords instead of $KeywordColor\n";
    print "  --linelabels       Generate a linexxx HTML label for each line\n";
    print "  --linenumbers      Add line numbers to the output\n";
    print "  --linkstyle style  Use the given link style\n";
    print "  --replaceext       Replace source extension instead of appending .html\n";
    print "  --textcolor c      Use text color c instead of $TextColor\n";
    print "  --verbose          Be more verbose\n";
}



#-----------------------------------------------------------------------------#
#	     		      	     Main      				      #
# ----------------------------------------------------------------------------#



# Get program options
GetOptions ("bgcolor=s"	      	=> \$BGColor,
            "colorize"          => \$Colorize,
            "commentcolor=s"    => \$CommentColor,
            "crefs"             => \$CRefs,
            "ctrlcolor=s"       => \$CtrlColor,
	    "cvttabs"		=> \$CvtTabs,
	    "debug!"   	      	=> \$Debug,
	    "help"     	      	=> \$Help,
	    "htmldir=s"	      	=> \$HTMLDir,
	    "indexcols=i"      	=> \$IndexCols,
	    "indexname=s"     	=> \$IndexName,
	    "indexpage"	      	=> \$IndexPage,
	    "indextitle=s"    	=> \$IndexTitle,
            "keywordcolor=s"    => \$KeywordColor,
            "linelabels"        => \$LineLabels,
            "linenumbers"       => \$LineNumbers,
	    "linkstyle=i"     	=> \$LinkStyle,
	    "replaceext"      	=> \$ReplaceExt,
	    "textcolor=s"     	=> \$TextColor,
       	    "verbose!" 	      	=> \$Verbose,
	    "<>"	      	=> \&AddFile);

# Check some arguments
if ($IndexCols <= 0 || $IndexCols >= 20) {
    Abort ("Invalid value for --indexcols option");
}
if ($HTMLDir ne "" && $HTMLDir =~ /[^\/]$/) {
    # Add a trailing path separator
    $HTMLDir .= "/";
}



# Print help if requested
if ($Help) {
    Usage ();
}

# Check if we have input files given
if ($FileCount == 0) {
    Abort ("No input files");
}

# Convert the documents
Pass1 ();
Pass2 ();

# Generate an index page if requested
if ($IndexPage) {
    CreateIndex ();
}

# Done
exit 0;

